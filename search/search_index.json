{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Music Combiner","text":"<ul> <li>Combine multiple tracks into a single one while preserving metadata</li> <li>I use it to combine multiple tracks from an OST into a single one :)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ul> <li>You need uv</li> <li>You need <code>ffmpeg</code></li> </ul>"},{"location":"#running","title":"Running","text":"<ul> <li><code>uv run combiner.py -f &lt;folder path&gt;</code></li> <li>Folder structure should be like this</li> <li>Main folder<ul> <li>Album 1 </li> <li>Song 1.mp3</li> <li>Song 2.mp3</li> <li>...</li> <li>Album 2</li> <li>Song 1.m4a</li> <li>Song 2.mp3</li> <li>...</li> </ul> </li> <li>Files will be saved as Album 1.m4a</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#app.combiner.main","title":"<code>main(parent_folder)</code>","text":"<p>Main function to process all the albums</p> Source code in <code>app/combiner.py</code> <pre><code>def main(parent_folder):\n    \"\"\"\n    Main function to process all the albums\n    \"\"\"\n    output_dir = os.path.join(parent_folder, \"merged_tracks\")\n    os.makedirs(output_dir, exist_ok=True)\n\n    tasks = []\n    for folder_name in os.listdir(parent_folder):\n        folder_path = os.path.join(parent_folder, folder_name)\n        if os.path.isdir(folder_path) and folder_name != \"merged_tracks\":\n            output_path = os.path.join(output_dir, f\"{folder_name}.m4a\")\n            tasks.append((folder_path, output_path, folder_name))\n\n    with ProcessPoolExecutor() as executor:\n        futures = [executor.submit(process_album, t) for t in tasks]\n        for _ in tqdm(\n            as_completed(futures),\n            total=len(futures),\n            desc=\"Merging Albums\",\n            unit=\"album\",\n        ):\n            pass\n\n    print(\"\\nProcessing complete!\")\n</code></pre>"},{"location":"api/#app.combiner.process_album","title":"<code>process_album(args)</code>","text":"<p>Runs ffmpeg to combine the songs, given a folder structure and audio extensions</p> Source code in <code>app/combiner.py</code> <pre><code>def process_album(args):\n    \"\"\"\n    Runs ffmpeg to combine the songs, given a folder structure and audio extensions\n    \"\"\"\n    folder_path, output_path, folder_name = args\n\n    files = sorted(f for f in os.listdir(folder_path) if f.lower().endswith(AUDIO_EXTS))\n\n    if not files:\n        return f\"Skipped: {folder_name} (No audio files)\"\n\n    # Use first track as metadata + cover-art source\n    first_track = os.path.join(folder_path, files[0])\n\n    list_file_path = os.path.join(folder_path, f\"list_{folder_name}.txt\")\n    with open(list_file_path, \"w\") as f:\n        for file in files:\n            safe_name = file.replace(\"'\", \"'\\\\''\")\n            f.write(f\"file '{safe_name}'\\n\")\n\n    cmd = [\n        \"ffmpeg\",\n        \"-y\",\n        # Metadata + cover art source\n        \"-i\",\n        first_track,\n        # Concatenated audio\n        \"-f\",\n        \"concat\",\n        \"-safe\",\n        \"0\",\n        \"-i\",\n        list_file_path,\n        # Map audio from concat input\n        \"-map\",\n        \"1:a\",\n        # Map cover art if present\n        \"-map\",\n        \"0:v?\",\n        # Copy metadata from first track\n        \"-map_metadata\",\n        \"0\",\n        # Audio encoding\n        \"-c:a\",\n        \"aac\",\n        \"-b:a\",\n        \"256k\",\n        # Preserve cover art\n        \"-c:v\",\n        \"copy\",\n        \"-disposition:v:0\",\n        \"attached_pic\",\n        output_path,\n    ]\n\n    try:\n        subprocess.run(\n            cmd,\n            check=True,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.STDOUT,\n        )\n        status = \"Success\"\n    except subprocess.CalledProcessError:\n        status = \"Error\"\n    finally:\n        if os.path.exists(list_file_path):\n            os.remove(list_file_path)\n\n    return f\"{status}: {folder_name}\"\n</code></pre>"}]}